---
author: gosunuts
title: 데이터베이스 서버와 임베디드 데이터베이스
---

## 데이터베이스 서버
데이터베이스 서버란, 독립된 서버 프로세스로 실행되며 네트워크를 통해 어플리케이션의 요청을 처리하는 데이터베이스를 의미합니다. MySQL, PostgreSQL, Oracle DB 등 우리에게 친숙한 대부분의 RDBMS가 이 모델에 해당합니다. 데이터베이스 서버는 다음과 같은 장점을 가지고 있습니다.
-   **중앙 집중 관리**: 데이터가 한곳에서 통합 관리되어 일관성, 보안, 백업 및 복구가 용이합니다.
-   **자원의 독립성**: 자체적인 CPU, 메모리, 스토리지를 할당받아 애플리케이션의 상태와 관계없이 안정적인 성능을 보장합니다.
-   **높은 동시성 및 확장성**: 많은 사용자의 동시 접근에 최적화되어 있으며, 클러스터링이나 복제를 통한 수평 확장이 비교적 수월합니다.

이러한 특성 덕분에 데이터베이스 서버는 지난 수십 년간 소프트웨어 인프라의 표준으로 자리 잡았습니다. 그러나 기술 발전과 환경 변화로 인해 일부 환경에서 데이터베이스 서버의 단점이 드러나기 시작했고, 그 대안으로 임베디드 데이터베이스가 다시 주목받고 있습니다.

## 새로운 흐름: 임베디드 데이터베이스
임베디드 데이터베이스는 별도의 서버 프로세스 없이, 애플리케이션에 라이브러리 형태로 포함되어 동일한 프로세스 내에서 실행되는 데이터베이스 엔진입니다. SQLite, LevelDB, RocksDB 등이 대표적인 임베디드 데이터베이스입니다. 이러한 임베디드 데이터베이스가 최신 기술 환경에서 강력한 대안으로 떠오른 배경은 다음과 같습니다.

-   **SSD의 등장**

    과거 HDD 중심의 시스템 환경에서는 순차적 데이터 읽기/쓰기 성능에 비해 무작위 접근 성능이 크게 떨어지는 특징이 있었습니다. 따라서 디스크 I/O를 최소화하고 메모리 캐싱을 극대화하는 것이 성능 최적화의 핵심이었습니다. 데이터베이스 서버는 이에 맞춰 대규모 캐시를 운영하고, 쓰기 연산을 모아 처리하는 방식으로 HDD의 물리적 한계를 극복해 왔습니다.

    그러나 SSD의 등장은 이러한 전제를 완전히 바꾸어 놓았습니다. SSD는 HDD에 비해 랜덤 I/O 성능이 수천 배 이상 빠르고, 지연 시간도 획기적으로 짧습니다. 그 결과 "디스크 I/O가 가장 큰 병목"이라는 기존의 인식이 사라지게 되었고, 오히려 네트워크를 통한 원격 DB 서버 접근에서 발생하는 지연이 새로운 병목 현상으로 부각되기 시작했습니다.

-   **MSA와 데이터 독립성**

    과거에는 하나의 거대한 모놀리식 애플리케이션이 하나의 중앙 집중식 데이터베이스에 의존하는 구조가 일반적이었습니다. 이 방식은 단순하지만, 서비스 규모가 커질수록 데이터 스키마 변경이 어려워지고, 모든 서비스가 동일한 DB를 공유하면서 결합도가 지나치게 강해지는 문제가 있었습니다.

    현대적인 마이크로서비스 아키텍처에서는 이러한 문제를 해결하기 위해 "Database per Service" 원칙이 중요시됩니다.각 서비스가 자신의 전용 데이터 저장소를 소유하고 캡슐화함으로써 서비스 간 독립성이 보장되며, 장애 격리와 확장이 쉬워집니다. 이 과정에서 임베디드 DB는 서비스 단위의 데이터 저장소로 이상적인 선택지가 됩니다. 가볍고 빠르며, 서비스 코드와 함께 배포될 수 있어 MSA 환경과 매우 잘 어울립니다.
    
    대표적으로 Kubernetes 환경에서는 사이드카 패턴을 통해 애플리케이션 컨테이너 옆에 임베디드 DB를 배치해 로컬 데이터 처리를 최적화하는 방식이 널리 사용됩니다. 이는 네트워크 병목을 줄이고 데이터 접근 지연을 최소화하는 효과를 가져옵니다.

-   **운영 환경 간소화**

    데이터베이스 서버는 설치, 패치, 백업, 장애 복구, 복제, 성능 모니터링 등 복잡한 운영 절차가 필수적이며, 이를 위해서는 전담 DBA와 전문적인 운영 인력이 필요합니다. 특히 대규모 환경에서는 이러한 관리 부담이 매우 큽니다. 

    임베디드 DB는 이러한 문제를 크게 완화시켜 줍니다. 데이터베이스가 애플리케이션 내부에 통합되면 단위 테스트, 빌드, 버전 관리, 배포가 함께 이루어지므로 별도의 서버 운영이 필요 없습니다. 또한 애플리케이션이 Scale-out 될 때 임베디드 DB도 함께 확장되며, DevOps 문화와 CI/CD 파이프라인을 통한 자동화된 관리가 가능해집니다. 특히 스타트업, 소규모 서비스, 프로토타입 개발 환경에서 임베디드 데이터베이스는 운영 복잡도를 획기적으로 낮추고 개발 및 배포 속도를 크게 높여 줍니다.

-   **고성능 시스템 언어와 생태계 발전**

    과거에는 데이터베이스와 애플리케이션이 서로 다른 언어로 작성되는 것이 일반적이었습니다. 예를 들어 고성능이 요구되는 데이터베이스 엔진은 주로 C, C++로 작성되었고, 애플리케이션은 Java, Python, PHP 등의 언어로 개발되었습니다. 이 방식은 성능 최적화에는 효과적이었지만, 메모리 안정성 문제, 복잡한 동시성 처리, 지연 시간, 그리고 라이브러리 통합 및 배포의 어려움이라는 한계가 있었습니다.

    그러나 최근 Go와 Rust 같은 현대적인 시스템 프로그래밍 언어가 부상하면서 이러한 한계는 크게 완화되었습니다. 특히 Go는 고성능 애플리케이션은 물론 데이터베이스 엔진과 같은 저수준 프로그램 작성에도 적합해, 데이터베이스와 애플리케이션을 하나의 언어 생태계 안에서 함께 다룰 수 있게 되었습니다.

    실제로 Golang 에서는 [BadgerDB](https://github.com/hypermodeinc/badger), [PebbleDB](https://github.com/cockroachdb/pebble)와 같은 고성능 임베디드 데이터베이스가 활발히 사용되고 있습니다. 이는 임베디드 데이터베이스가 단순히 데이터베이스 서버의 경량 대안을 넘어, 자체적인 경쟁력을 갖춘 중요한 선택지로 자리 잡고 있음을 의미합니다.

## 결론
대규모 데이터의 중앙 관리, 복잡한 트랜잭션, 높은 동시성이 필요한 조건에서는 여전히 데이터베이스 서버가 가장 강력한 해결책입니다. 하지만 MSA 환경의 개별 서비스, IoT 엣지 디바이스, 빠른 프로토타이핑, 그리고 운영 효율성이 중요한 프로젝트에서는 임베디드 데이터베이스가 더 효율적이고 합리적인 선택이 될 수 있습니다. 결국 중요한 것은 주어진 상황과 요구사항에 가장 잘 맞는 최적의 도구를 선택하는 것이며, 임베디드 데이터베이스의 발전은 우리에게 더 넓고 다양한 선택지를 제공해 주고 있습니다.