---
author: Gosunuts
title: FIPS 140 인증과 Golang
---

## FIPS 140 ( Federal Information Processing Standard Publication 140 )
**FIPS 140**은 미국 NIST가 제정한 암호 모듈 보안 인증 표준입니다. 이 표준은 특정 암호 모듈이나 라이브러리가 NIST가 정의한 보안 요구사항을 충족하는지를 평가합니다. 따라서 FIPS 140 인증을 통과했다는 것은 해당 모듈이 **공식적으로 신뢰할 수 있는 보안성**을 갖췄다는 의미이며, 금융, 의료, 국방 등 보안이 중요한 분야에서 사용될 수 있다는 것을 의미합니다.

FIPS 140 은 1994년 최초 제정된 이후로, 2001 년 FIPS 140-2 로, 2019년에는 FIPS 140-3 으로 개정되었습니다. 현재까지도 많은 시스템과 애플리케이션에서는 FIPS 140-2 또는 FIPS 140-3 인증을 요구하고 있습니다.

## FIPS 140 과 프로그래밍 언어
이러한 이유로, FIPS 140 인증을 받은 암호 모듈은 여러 프로그래밍 언어와 환경에서 사실상의 표준처럼 사용되고 있습니다. 대표적으로 OpenSSL, BoringSSL, LibreSSL, NSS 등이 있으며, 이들은 보안이 중요한 애플리케이션에서 가장 널리 활용되는 모듈입니다.

대부분의 FIPS 140 인증 모듈은 C 또는 C++로 작성되어 있습니다. 이 때문에 PHP, Python, Javascript 등의 언어에서는 이 모듈들을 직접 사용하기보다 외부 Provider 모듈을 통해 연동하는 방식으로 FIPS 환경을 구성합니다. 하지만 이런 접근 방식에는 몇 가지 한계가 존재합니다.

-   **버전 불일치 문제**

    FIPS 140 인증은 특정 버전에 대해서만 부여됩니다. 따라서 최신 버전의 모듈을 사용하려면 다시 인증 과정을 거쳐야 하며, 이 과정에서 애플리케이션이 사용하는 모듈과 FIPS 인증 모듈 간의 버전 불일치가 발생할 수 있습니다. 만약 인가되지 않은 버전을 사용한다면 해당 환경은 더 이상 FIPS 인증 환경으로 간주되지 않게 됩니다.

-  **동적 로딩과 성능 저하**

    대부분의 언어는 FIPS 140 인증 모듈을 동적 라이브러리 형태로 로드해 사용합니다. 이 방식은 초기화와 실행 과정에서 성능 저하를 유발할 수 있으며, 런타임 중 문제가 발생할 경우 애플리케이션 전체 안정성에 직접적인 영향을 미칠 위험이 있습니다.

-  **보안 취약점**

    위에서 말했듯이, OpenSSL Provider처럼 외부 모듈을 연동하는 구조에서는 해당 모듈의 보안 취약점이 애플리케이션에 직접 전파될 위험이 있습니다. 또한 애플리케이션과 외부 모듈 간의 통신 계층 자체가 추가적인 공격 표면이 되며, 이를 보호하기 위한 별도의 보안 계층이 필요해집니다. 이는 복잡성을 증가시켜 예기치 못한 취약점을 발생시킬 수 있습니다.

## FIPS 140 과 Golang
이러한 이유로 Golang 은 다른 전략을 취했습니다. Go 는 FIPS 140 인증을 외부 툴에 의존하지 않고, 공식 암호화 라이브러리에서 직접 지원하는 방식을 선택했습니다. 따라서 개발자는 별도의 Provider를 설치하거나 설정할 필요 없이, 표준 crypto 패키지를 그대로 사용하면서도 FIPS 인증 모드(GOFIPS=1)를 활성화하기만 하면 됩니다. 이 과정에서 외부 모듈과의 통신 경계가 제거되어 보안성이 강화되고, 정적 컴파일된 단일 바이너리만 배포하면 되므로 운영도 단순화됩니다.

### FIPS 140-2 와 Golang
이를 위해 Golang 은 BoringSSL 에서 파생된 BoringCrypto 모듈을 Go 런타임에 내장해 FIPS 140-2 인증을 획득했습니다. BoringCrypto 는 Go 1.19 버전 이후 특정 배포판에서 활성화할 수 있으며, 이를 통해 Go 애플리케이션은 별도의 외부 모듈 없이도 FIPS 140-2 인증 환경을 구성할 수 있습니다.

다만 BoringCrypto는 OpenSSL 기반이기 때문에 여전히 C 언어 의존성이 존재합니다. 따라서 Go 애플리케이션이 완전히 독립적인 바이너리로 빌드되지는 않으며, 필요한 C 라이브러리를 함께 배포해야 하는 제약이 있었습니다.

### FIPS 140-3 과 Golang
Go 팀은 이러한 한계를 극복하기 위해, 기존 Go 표준 crypto 라이브러리를 FIPS 140-3 규격에 맞게 개선했습니다. 이 개량된 모듈은 Go 1.21 버전부터 실험적으로 제공되기 시작했으며, 현재 NIST의 FIPS 140-3 인증 심사가 진행 중입니다.
[FIPS 140-3 module in process](https://csrc.nist.gov/projects/cryptographic-module-validation-program/modules-in-process/modules-in-process-list)

이는 Go 암호화 라이브러리의 성숙도를 보여주며, 이를 통해 Go 는 완전히 독립적인 단일 바이너리로 FIPS 140-3 인증 환경을 제공할 수 있게 되었습니다.

또한, Go 팀은 단순히 FIPS 140-3 표준을 충족하는 데 그치지 않고, 자체적으로 보안성을 강화했습니다.

-   **Fail Fast**

    Go 의 FIPS 모드는 Fail Fast 보안 모델을 적용하여, 비인증 알고리즘을 호출하면 panic 으로 즉시 실행을 중단합니다. 이는 다른 언어의 Provider 기반 모델이 fallback 가능성을 남기는 것과 달리, 보안과 규제 준수 측면에서 더 엄격하고 명확한 보증을 제공합니다.

-   **Hedged Signature**

    FIPS 140-3 표준에서는 ECDSA 서명 시 RFC6979 방식을 권장합니다. 하지만 Go 는 여기에 더해 Hedged 방식을 도입하여, 서명 과정에서 발생할 수 있는 사이드 채널 공격에 더 강력하게 대응합니다.

-   **강화된 난수 생성기**

    Go 의 난수 생성기는 사용자 공간 DRBG(Deterministic Random Bit Generator) 를 사용하면서도, 운영체제 커널에 대한 엔트로피를 추가로 주입하여, 사용자 공간 뿐만 아니라 커널 공간에서도 높은 품질의 난수를 생성합니다. 이를 통해 난수 생성기의 보안성을 더욱 강화합니다.