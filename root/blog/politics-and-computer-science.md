---
id: b512d90615e48e4767b79aba30ad4089
author: snowmerak
title: 정치와 컴퓨터
description: 정치와 컴퓨터 공학, 서로 다른 듯 닮은 두 분야가 어떻게 사회 문제를 해결하고, 개발자가 새로운 입법자가 되는지 탐구합니다.
language: ko
date: 2025-08-29T16:17:11.199526621Z
path: /blog/posts/politics-and-computers-zc4a4a358
---

## 철학이란

철학이란 무엇이라 생각하시나요? 사전적 의미는 `세상의 삶과 근본적인 질문에 대해 생각하고 답을 찾아가는 할동`라고 합니다.  답이 정해진 문제 풀이가 아니라 같은 질문, 혹은 꼬리를 무는 질문의 연속으로 사고를 확장하고, 그 답을 공유하는 것이라는 행위적 정의도 걸 수 있죠.

과거 저는 학사 과정을 수료하던 중, 정치철학과 관련된 과목을 수강한 적이 있습니다. 그때에 제 자기소개 시간에 교수님은 `정치철학과 컴퓨터공학은 서로 다른 철학의 정점에 있는 학문이다`와 유사한 말씀을 하셨던 기억이 있습니다. 정확히 이 단어와 문장은 아니었지만, 대충 그런 뜻이었던 것같습니다.

### 컴퓨터 공학

저는 컴퓨터 공학은 `논리적 문제를 해결하기 위한 근본적 탐구`라고 생각합니다. 그렇기에 어떠한 문제에 대해 사고하는 사람마다 여러가지 답이 나올 수 있죠. 가장 대표적인 예가 정렬입니다. 같은 나열된 데이터를 순서대로 정렬하는 방법에 대한 탐구에도 버블, 삽입, 선택, 병합, 퀵, 힙, 팀 등 여러가지가 존재하죠. 그리고 이를 나누면서 더 나은 알고리즘이 나올 수 있죠.

또한 지역적으로 본다면, `만들고 증명한다`고 할 수도 있겠습니다. 바로 위 정렬도 어떻게 정렬할 것인지 계속 만들고 결과를 증명하죠. 개발자인 분들은 더욱 가까운 예시로 프로젝트 기획이 나오면, 구현하고 멀쩡히 돌아감을 증명하는 것으로 보면 좋습니다.

### 정치 철학

저는 정치 철학은 `사회적 문제를 해결하기 위한 근본적 탐구`라고 생각합니다. 각 시대마다 다른 이미 존재하는 문제에 대해 반복적으로 의문을 제기하고, 답을 산출하며, 현재와 미래에 공유합니다. 정의, 자유, 평등, 권력과 같이 시대와 문화에 따라 다르게 해석되는 추상적인 가치를 주로 다루며 명확한 선과 악, 정답과 오답이 정해져 있지 않고, 정해지지 않는 특징이 있죠.

또한 컴퓨터 공학처럼 지역적으로 본다면, `질문하고 성찰한다`고 볼 수 있습니다. 발생한 문제에 대해 끊임없이 질문하고, 왜 그렇게 되었는가, 더 나은 방향은 무엇이 있는가, 성찰하고 답을 냅니다. 이 또한 사고하는 사람 수에 비례해서 많은 답이 나타나죠.

## 우리는 왜 정치/컴퓨터도 알아야 하나

### 상호 호출의 관계

두 세계는 서로 다른 영역을 파헤치는 것 같지만 실제로는 상당히 유사한 점을 공유하고 있으며, 서로의 원인과 결과가 되는 점을 상당히 많이 가지고 있습니다. 

한가지 예를 들어 보겠습니다.

1. 개인의 건강 데이터를 안전하게 클라우드에 저장하면, 필요할 때에 각 병원에서 빠르게 접근할 수 있을 거야 ⇒ 프로그래밍으로 안전하고 접근성 좋게 각 영역의 기능을 이용해서 구현합니다.
2. 그러면 해당 데이터는 누구의 것이지? 나? 등록한 담당자? 아니면 주관사? 개발사? 국가? 그럼 그들은 내 데이터의 어디까지 볼 수 있지? 내 개인 정보를 어디까지 어떻게 보호가 된다고 보장받을 수 있지? ⇒ 서로 다른 공동체들과 각 개인들의 입장과 이해 차에 대한 정치적 담론이 오갈 것입니다.
3. 이후로는 때때로 이에 대해 정치적 담론과 프로그래밍적 설계와 구현이 꼬리를 물고 반복되겠죠.

이처럼, 기존 사회 문제를 해결하기 위해 컴퓨터 공학이 쓰이고, 다시 여기서 발생한 문제를 인지하고 해결하기 위해 의문을 제기하고 다음 문제를 해결하기 위해 정치 철학이 쓰이게 됩니다. 정보화 사회인 현대에 이는 당연한 현상이죠.

## 정치와 컴퓨터는 닮은 꼴일까

### 그렇지 않아 보이는 점

또한 두 세계는 유사한 형태로 진화해 왔습니다. 하지만 그 근간은 사회 철학과 자연 철학의 관계와 마찬가지로 모호한 표현과 명확한 표현의 차이가 있습니다. 정치 철학에선 자연어로 이루어진 가변적이고 모호한 정의를 기반으로 한다면, 컴퓨터 공학은 자연어보다는 수식으로 이루어진 불변하고 명확한 명제를 기반으로 하죠.

또한 방향성도 미묘하게 다르게 표현하죠. 컴퓨터 공학은 최적해가 존재할 수 있다고 봅니다. 그리고 정치 철학에선 더 설득력 있는 주장, 더 근거 있는 주장, 더 윤리적인 주장같은 모호한 개념을 이야기하죠. 하지만 제가 볼 때 둘의 방향성은 거의 유사합니다. 결국 `더 나은 다음`을 도모하는 것으로 보이거든요. 당장 컴퓨터 공학도 다양한 분야가 있지만, 대표적으로 코덱이라 불리는 미디어 압축에 대해서는 더 나은 압축률과 압축 성능, 라이센스 비용을 보여주기 위해 노력하고 있죠.

### 비슷한 것같은 점

대표적으로 프로그래밍 언어와 통치 이념은 인간에게 유사하게 적용되는 것으로 보입니다. 각 언어와 이념을 대응 시킬 수 없으나 재미로 나열해보겠습니다.

- C 언어 (`개발자는 자신이 무엇을 하는지 알고 있다`): 저는 공화주의에 빗대고 싶습니다. 역사적으로 서구 정치 체제의 근간이 된 공화정과 비슷하고, 시민 개개인의 의식과 더 나은 이상을 향해 나아가려는 개개인의 노력을 중시하는 공동체 주의와도 닮아 있다고 보기 때문입니다. 또한 권리에는 책임이 따르는 점이 유사하다고 느껴졌습니다.
- Java (`한 번 작성하면, 어디서든 실행된다`): 모르겠습니다. 강력한 법이 있고, 그걸 지키며 획일화된 삶을 살지만, 그것이 안정적이고 그 안에서는 자유롭습니다. 그리고 스프링으로 들어가면 다양한 복지들이 여러분들을 기다리고 있죠. 자유주의로 할까요?
- C# (`개발자 생산성과 소프트웨어 공학 원칙의 조화`): 강한 정부의 비호 아래 모든 게 잘 설계되어 있고, 이 위에서 계획된 것 내에선 생산성과 성능을 극한으로 끌어낼 수 있습니다. 계획경제가 어울립니다. 공산주의가 아닌 점은, 생산 수단을 풀었고 생산자를 제한하지 않습니다.
- Go (`복잡성은 버리고, 실용성과 효율성을 취한다`): 비슷한 게 없습니다. 다 퍼주니 복지국가 하십쇼.
- Rust (`성능 저하 없는 안전성`): 러스트의 소유권과 라이프타임은 엄격한 컴파일러라는 통치자에 의해 관리됩니다. 이는 개인의 자유로운 경제 활동이 낳는 불평등과 위험을 막기 위해, 공동체가 생산 수단을 관리하고 계획하여 안정적인 삶을 보장한다는 것, 그것이 개인의 자유를 일부 제한하여 시스템 전체의 안전과 평등을 추구하는 것으로 보여 사회주의라 생각합니다.
- JavaScript (`유연성과 관용성, 그리고 어디에나 존재함`): 자본주의에 빗대고 싶습니다. 이 언어는 생산 수단을 개개인이 가지게 되고, 심지어 설비도 개개인이 넉넉하게 가집니다. 덕분에 다양한 공산품이 나오고, 자유로운 경쟁을 통해 누구나 이윤을 추구할 수 있게 되었습니다. 하지만 규제가 없는 시장은 곧 혼돈에 빠졌죠.
- TypeScript (`확장되는 JavaScript`): 당연히 수정 자본주의입니다. 자본주의의 믿음이 깨지고, 시장의 불안정성을 타파하기 위해 어느 정도 정부가 개입하게 됩니다. 기존의 완전한 자유는 비교적 퇴보 했지만, 여전히 누구나 자유롭게 시장에 뛰어들어 경쟁합니다.

그리고 생각보다 적지 않은 개발자들이 마치 현실에서 이념 전쟁을 하듯, 언어로 많이 싸웁니다. 언어 자체가 개발자에게 익숙한 이념이자, 추구해야 할 이상인 셈이죠.

#### 국가와 아키텍처

- 모놀리식 아키텍처와 중앙집권 국가: 하나의 거대한 코드 베이스와 하나의 바이너리에 모든 것이 포함됩니다. 이는 강력한 중앙 정부를 가지는 단일 국가나 절대 왕정과 유사한 구조를 가집니다. 국가의 모든 기능이 하나의 권력 체제에 의해 통제되죠.
    - 국가의 형태를 갖추기 가장 쉽고 의사 결정이 빠르게 나온다는 장점이 있습니다. 이는 전체 소프트웨어가 빨리 나온 다는 장점과 같은 맥락이죠. 모든 자원과 정보가 한 곳에 몰려 있기에 관리하기 명확합니다.
    - 다만 국가가 커질 수록 변화에 대응하기 어려우며, 작은 법이나 제도를 바꾸려 해도 전체를 검토하고 적용해야 합니다. 한 분야의 문제가 국가 전체를 마비 시킬 위험도 따르죠. 모놀리식 또한 큰 코드 베이스와 엮인 코드로 인해 변화에 대응하기 어렵고, 코드 한 줄 바꾸려 해도 영향 범위를 산정하고, 한 모듈에서 발생한 문제가 시스템 전체에 영향을 끼치기 쉽습니다.
- MSA와 연방제 국가: 시스템의 각 기능이 독립적인 서비스로 분리됩니다. 이는 국가의 각 부분이 여러 독립적인 주로 구성되는 연방제 국가와 유사점을 가집니다. 또한 각 서비스와 주는 독립적인 인프라를 가지게 되죠. 중앙 정부의 간섭은 느슨한 편으로 언제 독립과 가입이 발생할지 모르는 것 또한 유사합니다.
    - 기본적으로 각 독립 주와 서비스는 독립적으로 법률을 개정/코드를 작성할 수 있습니다. 이로 인해 서로의 템포를 맞출 필요가 없습니다. 또한 한 곳에서 문제가 생긴다 해도 연방 전체가 마비되기 힘듭니다. 그리고 각 지역이나 분야에 따른 적합한 제도(기술)을 선택할 수 있습니다.
    - 하지만 상호 간의 합의를 맞춘다거나 통신 채널을 만드는 것은 어려운 점입니다. 일관된 정책을 펴기 어려워 혼란을 야기할 수도 있죠.
- EDA(Event Drive Architecture)와 시민 사회: 중앙 정부나 대리인이 직접적으로 명령을 하기보다 발생한 사회적 문제를 개개인이 주도적으로 자율적으로 주워가서 해결합니다. 이는 EDA의 특징인 이벤트가 발생하면 구독자 중 누군가 자율적으로 주워가서 처리하는 것과 유사합니다.
    - 누구나 쉽게 참여할 수 있습니다. EDA 또한 새로운 서비스가 쉽게 새로운 구독자가 되어 프로세스에 참여할 수 있습니다.
    - 하지만 전체 흐름을 파악할 수 없다는 단점이 있습니다. 누가 어떻게 처리했는지 추적하기 어렵고, 하나의 사건이 어떤 연쇄 반응을 일으킬지 알 수 없습니다.
- Layerd Architecture와 봉건제: 봉건제는 각자의 계층에서 주어진 역할과 책임을 다하여, 상위 계층에 대한 의무를 수행하는 구조입니다. 이들은 일종의 계약 관계로 맺어지며, 엄격한 수직적 지배구조를 이룬다는 점에서 레이어드 아키텍처와 유사점을 찾을 수 있습니다.

이처럼 더 많은 비유가 가능하지만, 이 글의 핵심은 구조 자체보다 그 구조를 만들어가는 과정에 있습니다.

## 개발과 정치의 문제 해결은 같을 지도?

소프트웨어 아키텍처와 국가 체제가 닮았다면, 그 둘을 만들어가는 과정 역시 놀랍도록 평행선을 그립니다. 소프트웨어를 개발하는 과정은 사실상 디지털 공간에 새로운 질서를 구축하고 발전시켜 나가는 정치 행위와 다르지 않습니다.

1. 사회 문제의 공론화와 요구사항 분석**:** 모든 것은 "무엇이 문제인가?"라는 질문에서 시작합니다. 시민 사회의 고통과 불편함이 공론화되어 정치적 의제가 되듯, 사용자의 불편함과 요구는 분석을 거쳐 '요구사항 명세서'라는 개발의 첫 이정표가 됩니다.
2. 헌법 설계와 아키텍처 디자인**:** 어떤 국가를 만들 것인가? 어떤 시스템을 만들 것인가? 정치인들이 이념과 철학을 바탕으로 헌법과 법률의 뼈대를 세우듯, 아키텍트는 기술적 신념을 바탕으로 시스템의 근간이 될 아키텍처의 청사진을 그립니다. 이 단계의 결정이 시스템의 운명을 좌우합니다.
3. 정책 집행과 소프트웨어 구현**:** 설계도가 완성되면 개발자들은 실제 코드를 작성하고, 행정 관료들은 법률에 따라 정책을 집행합니다. 추상적인 계획이 현실 세계에서 작동하는 구체적인 실체로 태어나는 과정입니다.
4. 선거를 통한 심판과 소프트웨어 테스트**:** 정책은 선거와 여론을 통해 그 정당성을 심판받습니다. 소프트웨어는 QA팀의 테스트와 사용자의 피드백을 통해 그 가치를 검증받습니다. 둘 다 결국 주권자(시민, 사용자)의 동의를 얻어야만 생존할 수 있습니다.
5. 제도 개혁과 시스템 유지보수**:** 한번 만든 법과 시스템은 영원하지 않습니다. 시대의 변화에 맞춰 낡은 법을 개정하고 제도를 개혁하듯, 소프트웨어 역시 변화하는 환경에 적응하고 내부의 비효율을 개선하는 '리팩토링'을 멈추는 순간 죽은 코드가 되어버립니다.

이처럼 문제 정의부터 설계, 구현, 검증, 그리고 끊임없는 개선에 이르는 전 과정은 두 세계가 같은 문제 해결의 호흡을 공유하고 있음을 보여줍니다.

## 새로운 입법자들의 날

정보화 사회는 그 두 철학의 정점 사이의 거리를 무의미하게 만들었습니다. 코드는 더 이상 단순한 논리 회로가 아니라, 사람들의 관계를 규정하고, 권력을 분배하며, 사회적 가치를 실현하는 '법(Code is Law)'이 되었습니다. 우리가 설계하는 아키텍처가 국가의 통치 구조와 닮아있고, 우리가 따르는 개발 프로세스가 정치적 합의 과정과 같다면, 우리 개발자들은 과연 누구일까요? 또 정치인은 무엇을 해야할까요?
그렇기에 개발자는 이제 코드의 논리뿐만 아니라 그 코드가 만들 사회를 성찰해야 하고, 정치인은 표의 논리뿐만 아니라 세상을 움직이는 기술의 논리를 이해해야 합니다. 우리가 각자의 세계에서 휘두르는 이 막강한 권력에는 그만큼의 윤리적 책임이 따르기 때문입니다.